{"ast":null,"code":"import { camelize, wrapInArray } from './helpers';\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  const styleMap = {};\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n\n    if (!key) {\n      continue;\n    } // May be undefined if the `key: value` pair is incomplete.\n\n\n    if (typeof val === 'string') {\n      val = val.trim();\n    }\n\n    styleMap[camelize(key)] = val;\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = { ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\nexport function mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\nexport function mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? wrapInArray(target).concat(source) : source;\n}\nexport function mergeListeners(...args) {\n  if (!args[0]) return args[1];\n  if (!args[1]) return args[0];\n  const dest = {};\n\n  for (let i = 2; i--;) {\n    const arg = args[i];\n\n    for (const event in arg) {\n      if (!arg[event]) continue;\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n\n  return dest;\n}","map":{"version":3,"mappings":"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","names":["camelize","wrapInArray","pattern","styleList","styleProp","parseStyle","style","styleMap","s","split","key","val","trim","mergeData","mergeTarget","i","arguments","length","prop","Object","keys","mergeClasses","mergeStyles","undefined","mergeListeners","target","source","concat","args","dest","arg","event"],"sourceRoot":"","sources":["../../src/util/mergeData.ts"],"sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (...args: [\n  { [key: string]: Function | Function[] } | undefined,\n  { [key: string]: Function | Function[] } | undefined\n]) {\n  if (!args[0]) return args[1]\n  if (!args[1]) return args[0]\n\n  const dest: { [key: string]: Function | Function[] } = {}\n\n  for (let i = 2; i--;) {\n    const arg = args[i]\n    for (const event in arg) {\n      if (!arg[event]) continue\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = ([] as Function[]).concat(arg[event], dest[event])\n      } else {\n        // Straight assign.\n        dest[event] = arg[event]\n      }\n    }\n  }\n\n  return dest\n}\n"]},"metadata":{},"sourceType":"module"}